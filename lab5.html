<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>北京城区一周内的道路拥堵情况</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .line {
      fill: none;
      stroke-width: 5;
    }
    .axis path,
    .axis line {
      fill: none;
      shape-rendering: crispEdges;
    }
    .circle {
      fill: black;
    }
    .tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 5px;
      border-radius: 5px;
      pointer-events: none;
      visibility: hidden;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #98D8AA;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #FF9F45;
    }
    .svg-container {
      position: relative;
      width: 90vw;
      height: 60vh;
      margin: 0 auto;
    }
    /* line SVG */
    #line {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
    }

    /* pie SVG */
    #pie {
      position: absolute;
      top: 5vh;
      left: 1vw;
      width: 30vw;
      height: 20vw;
      z-index: 1;
    }
    .slice {
      fill: steelblue;
      stroke: #fff;
      stroke-width: 1px;
    }
    .label {
      font-size: 15px;
      text-anchor: middle;
      fill: black;
    }
    /* 添加堆叠面积图的样式 */
    .area {
      opacity: 0.7;
    }
    .legend {
      font-size: 12px;
    }
    #button-container {
      width: 90vw;
      margin: 0 auto;
      padding-left: 40px;
    }
    button.active {
      background-color: #54B435 !important;
      color: white;
    }
  </style>
</head>

<body>
  <h1 style="text-align: center; margin: 20px 0; color: #333; font-family: Arial, sans-serif;">
    北京城区一周内的道路拥堵情况
  </h1>
  
  <div style="width: 90vw; margin: 0 auto;">
    <div id="button-container"></div>
  </div>
  <div class="svg-container">
    <svg width="100%" height="100%" id="line"></svg>
    <svg width="30%" height="30%" id="pie"></svg>
  </div>
  <div style="margin-top: 20px; margin-left: auto; margin-right: auto; width: 90vw;">
    <svg width="100%" height="30vh" id="stackedArea"></svg>
  </div>
  <svg width="90vw" height="50vh" id="pic" preserveAspectRatio="xMidYMid meet"></svg>
  <div id="tooltip" class="tooltip"></div>
  <script>
    const buttonData = [
      { label: "12.01", day: "Sun", csvFile: "data1.csv", road: "road1.csv"},
      { label: "12.02", day: "Mon", csvFile: "data2.csv", road: "road2.csv"},
      { label: "12.03", day: "Tue", csvFile: "data3.csv", road: "road3.csv"},
      { label: "12.04", day: "Wed", csvFile: "data4.csv", road: "road4.csv"},
      { label: "12.05", day: "Thu", csvFile: "data5.csv", road: "road5.csv"},
      { label: "12.06", day: "Fri", csvFile: "data6.csv", road: "road6.csv"},
      { label: "12.07", day: "Sat", csvFile: "data7.csv", road: "road7.csv"},
    ];
    const container = d3.select("#button-container");
    // 使用 D3 创建并添加 7 个按钮
    container.selectAll("button")
             .data(buttonData)  // 将按钮数据绑定到每个按钮
             .enter()
             .append("button")
             .html(d => `${d.label}, ${d.day}`)  // 使用 HTML 格式化文本
             .style("margin", "5px")
             .style("padding", "10px 20px")
             .style("font-size", "16px")
             .style("background-color", "#98D8AA")
             .style("border", "none")
             .style("cursor", "pointer")
             .style("border-radius", "5px")
             .on("click", function(event, d) {
                // 移除其他按钮的active类
                d3.selectAll("button").classed("active", false);
                // 为当前按钮添加active类
                d3.select(this).classed("active", true);
                
                d3.select("#line").selectAll("*").remove();
                drawLineChart(d.csvFile);  // 点击时加载不同的CSV
                
                // 清空并重绘点图
                d3.select("#pic").selectAll("*").remove();
                drawPointMap(d.road);
              })
    // 1. 加载 CSV 文件
    function drawLineChart(csvFile) {
      d3.csv(csvFile).then(function(data) {
        // 2. 解析日期和数值
        data.forEach(function(d) {
          const year = 2024;  // 获取当前年份
          const month = 12;  // 月份（MM）
          const day = d.time.substring(0, 2);    // 日期（DD）
          const hour = d.time.substring(3, 5);   // 小时（HH）
          const minute = d.time.substring(6, 8); // 分钟（MM）
          // 构建标准日期字符串：YYYY-MM-DD HH:MM
          const dateStr = `${year}-${month}-${day} ${hour}:${minute}`;
          d.time = new Date(dateStr);
          d.value = +d.value; // 转换为数字
        });
        // 3. 设置图表的尺寸和边距
        const margin = { top: 20, right: 30, bottom: 40, left: 40 };
        const container = d3.select("#line").node().getBoundingClientRect();
        const width = container.width - margin.left - margin.right;
        const height = container.height - margin.top - margin.bottom;
        const x = d3.scaleTime()
                    .domain(d3.extent(data, d => d.time))  // 使用日期的最小最大值作为 x 轴的范围
                    .range([0, width]);
        const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);     
        // 4. 创建线生成器
        const line = d3.line()
                       .x(d => x(d.time))
                       .y(d => y(d.value))
                       .curve(d3.curveCardinal);
        // 5. 创建SVG元素并添加折线
        const svg = d3.select("#line")
                      .attr("width", width + margin.left + margin.right)
                      .attr("height", height + margin.top + margin.bottom)
                      .append("g")
                      .attr("transform", `translate(${margin.left},${margin.top})`);
        // 6. 添加折线图路径
        const linePath = svg.append("path")
                          .data([data])
                          .attr("class", "line")
                          .attr("d", line)
                          .attr("stroke", "url(#gradient)") // 使用渐变
                          .attr("stroke-width", 2)
                          .attr("fill", "none");
        // 获取路径的总长度
        const pathLength = linePath.node().getTotalLength();

        // 设置初始状态：路径长度为 0
        linePath
            .attr("stroke-dasharray", pathLength + " " + pathLength)
            .attr("stroke-dashoffset", pathLength)
            .transition()  // 开始动画
            .duration(2000)  // 动画时长：2秒
            .attr("stroke-dashoffset", 0);  // 逐步绘制路径
        // 7. 创建渐变色
        const gradient = svg.append("defs")
                            .append("linearGradient")
                            .attr("id", "gradient")
                            .attr("x1", "0%")
                            .attr("y1", "100%")  // 从下到上渐变
                            .attr("x2", "0%")
                            .attr("y2", "0%");
        gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "#98D8AA");
        gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "#FF4B4B");
        // 8. 添加x轴
        svg.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(x).ticks(24));
        // 9. 添加y轴
        svg.append("g")
          .call(d3.axisLeft(y).ticks(12));
        // 10. 添加圆圈到每个数据点
        svg.selectAll(".dot")
          .data(data)
          .enter().append("circle")
          .attr("class", "circle")
          .attr("cx", d => x(d.time))
          .attr("cy", d => y(d.value))
          .attr("r", 3)
          .on("mouseover", function(event, d) {
            d3.select(this).attr('r', 5)
            // 显示tooltip
            const tooltip = d3.select("#tooltip");
            tooltip.style("visibility", "visible")
                   .html("Time: " + d.time + "<br/>Value: " + d.value)
            // 更新tooltip位置
            tooltip.style("top", (event.pageY + 3) + "px")
                   .style("left", (event.pageX + 3) + "px");

            const data = [d.a,d.b,d.c,d.d];  // 你可以修改这里的数字，数据可以是百分比或数值
            // 创建饼状图的饼生成器
            const pie = d3.pie()
              .value(d => d);  // 使用数据的值来计算角度

            // 获取容器的实际尺寸
            const pieContainer = d3.select("#pie").node().getBoundingClientRect();
            const radius = Math.min(pieContainer.width, pieContainer.height) / 4;
            
            const arc = d3.arc()
              .innerRadius(0)
              .outerRadius(radius);
            
            const svg = d3.select('#pie')
              .attr('width', '100%')
              .attr('height', '100%')
              .append('g')
              .attr('transform', `translate(${pieContainer.width/2}, ${pieContainer.height/2})`);
            
            // 设置每个扇区的颜色
            const colors = ['#FF4B4B', '#FF9F45', '#FFD371', '#98D8AA'];
            // 绑定数据并创建扇区
            const slices = svg.selectAll('.slice')
              .data(pie(data))
              .enter()
              .append('path')
              .attr('class', 'slice')
              .attr('d', arc)  // 使用弧生成器来计算路径
              .style('fill', (d, i) => colors[i]);  // 根据数据项的索引映射颜色

            // 添加图例
            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${radius * 1.2}, ${-radius})`);  // 将图例放在饼图右上方

            // 添加图例项
            const legendItems = [
                { label: '严重拥堵', color: colors[0], value: data[0] },
                { label: '拥挤', color: colors[1], value: data[1] },
                { label: '缓行', color: colors[2], value: data[2] },
                { label: '畅通', color: colors[3], value: data[3] }
            ].filter(item => item.value > 0);  // 过滤掉值为0的项

            legend.selectAll("rect")
                .data(legendItems)
                .enter()
                .append("rect")
                .attr("x", 0)
                .attr("y", (d, i) => i * 20)
                .attr("width", 12)
                .attr("height", 12)
                .style("fill", d => d.color);

            legend.selectAll("text")
                .data(legendItems)
                .enter()
                .append("text")
                .attr("x", 20)
                .attr("y", (d, i) => i * 20 + 10)
                .style("font-size", "12px")
                .style("fill", "#333")
                .text(d => `${d.label}: ${d.value}%`);
          })
          .on("mouseout", function() {
            d3.select(this).attr('r', 3)
            // 隐藏tooltip
            d3.select("#tooltip").style("visibility", "hidden");
            // 清空饼图
            d3.select("#pie").selectAll("*").remove();
          });

        // 绘制堆叠面积图
        drawStackedArea(data);
      });
    }

    // 添加绘制堆叠面积图的函数
    function drawStackedArea(data) {
      // 清除现有图表
      d3.select("#stackedArea").selectAll("*").remove();
      
      const margin = { top: 20, right: 30, bottom: 40, left: 40 };
      const container = d3.select("#stackedArea").node().getBoundingClientRect();
      const width = container.width - margin.left - margin.right;
      const height = container.height - margin.top - margin.bottom;

      const svg = d3.select("#stackedArea")
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // 准备数据
      const keys = ['a', 'b', 'c', 'd'];
      const stack = d3.stack().keys(keys)(data);

      // 比例尺
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, width]);

      const y = d3.scaleLinear()
        .domain([0, 100])
        .range([height, 0]);

      // 定义面积生成器
      const area = d3.area()
        .x(d => x(d.data.time))
        .y0(d => y(d[0]))
        .y1(d => y(d[1]));

      // 颜色比例尺
      const color = d3.scaleOrdinal()
        .domain(keys)
        .range(['#FF4B4B', '#FF9F45', '#FFD371', '#98D8AA']);

      // 绘制面积
      svg.selectAll("path")
        .data(stack)
        .join("path")
        .attr("class", "area")
        .attr("d", area)
        .style("fill", d => color(d.key));

      // 添加坐标轴
      svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x));

      svg.append("g")
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d + "%"));

      // 添加图例
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width - 100}, 10)`);

      const legendItems = [
        { key: 'a', label: '严重拥堵' },
        { key: 'b', label: '拥挤' },
        { key: 'c', label: '缓行' },
        { key: 'd', label: '畅通' }
      ];

      legend.selectAll("rect")
        .data(legendItems)
        .join("rect")
        .attr("x", 0)
        .attr("y", (d, i) => i * 20)
        .attr("width", 15)
        .attr("height", 15)
        .style("fill", d => color(d.key));

      legend.selectAll("text")
        .data(legendItems)
        .join("text")
        .attr("x", 20)
        .attr("y", (d, i) => i * 20 + 12)
        .text(d => d.label);
    }

    // 添加绘制点图的函数
    function drawPointMap(roadFile) {
      d3.csv(roadFile).then(function(data) {
        // 设置原始宽高比
        const originalWidth = 1221;
        const originalHeight = 1052;
        const aspectRatio = originalHeight / originalWidth;
        
        // 获取容器的实际尺寸
        const container = d3.select("#pic").node().getBoundingClientRect();
        let width = container.width;
        let height = container.height;
        
        // 调整高度以保持原始比例
        if (height / width > aspectRatio) {
          height = width * aspectRatio;
        } else {
          width = height / aspectRatio;
        }
        
        // 获取SVG画布
        const svg = d3.select("#pic")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${originalWidth} ${originalHeight}`);  // 使用原始尺寸的viewBox

        // 确定经纬度的最小值和最大值
        const lonMin = d3.min(data, d => +d['经度']);
        const lonMax = d3.max(data, d => +d['经度']);
        const latMin = d3.min(data, d => +d['纬度']);
        const latMax = d3.max(data, d => +d['纬度']);

        // 设置比例尺，使用原始尺寸
        const xScale = d3.scaleLinear()
            .domain([lonMin, lonMax])
            .range([originalWidth * 0.05, originalWidth * 0.95]);

        const yScale = d3.scaleLinear()
            .domain([latMin, latMax])
            .range([originalHeight * 0.95, originalHeight * 0.05]);

        // 绘制每个点，设置圆的颜色根据value值
        svg.selectAll("circle")
            .data(data)
            .enter().append("circle")
            .attr("cx", d => xScale(+d['经度']))
            .attr("cy", d => yScale(+d['纬度']))
            .attr("r", 2)  // 圆的半径
            .attr("fill", function(d) {
                switch (+d['value']) {
                    case 4: return "#98D8AA";  // 通畅
                    case 3: return "#FFD371";  // 缓行
                    case 2: return "#FF9F45";  // 拥挤
                    case 1: return "#FF4B4B";  // 严重拥堵
                    default: return "black";    // 默认情况
                }
            });
      });
    }

    // 添加窗口大小改变时的处理
    window.addEventListener('resize', function() {
      // 清除当前图表
      d3.select("#line").selectAll("*").remove();
      d3.select("#pie").selectAll("*").remove();
      
      // 重新绘制当前显示的图表
      const currentButton = d3.select("button.active");
      if (currentButton.size()) {
        drawLineChart(currentButton.datum().csvFile);
      }
    });
  </script>
</body>
</html>